# Глава 2. Режим точка-точка

Сначала, режим «точка-точка» с использованием общих ключей был единственным доступным вариантом при использовании OpenVPN. В настоящее время существует несколько способов использования OpenVPN, но режим «точка-точка» все еще имеет свое применение. Термин _двухточечный режим с использованием предварительно установленных общих ключей_ часто сокращается до **предустановленных ключей**.

В режиме «точка-точка» OpenVPN настраивается с использованием предустановленных общих секретных ключей для предварительно определенных конечных точек, и только одна конечная точка может одновременно подключаться к экземпляру сервера. Термин сервер можно считать вводящим в заблуждение, поскольку обе конечные точки более или менее равны, когда речь заходит о функциональности. Конечная точка, инициирующая соединение, считается клиентом, а другая конечная точка рассматривается как сервер.

Мы начнем с демонстрации очень простого примера. После этого мы обсудим больше возможностей, которые предоставляет OpenVPN. Мы рассмотрим следующие темы:

* Протокол TCP и разные порты
* Режим TAP
* Секретные ключи OpenVPN
* Маршрутизация
* Полная настройка, включая IPv6
* Настройка без IP
* Трехсторонняя маршрутизация
* Мостовые адаптеры TAP на обоих концах
* Комбинированный двухточечный режим с сертификатами

## Плюсы и минусы ключевого режима

Основным вариантом использования режима предустановленного общего ключа является подключение двух удаленных сетей, например, главного офиса и удаленного офиса небольшой компании. Как только требуется более трех пользователей или конечных точек, гораздо проще использовать режим клиент/сервер, как описано в [Главе 4](chapter-04.md), _Режим клиент/сервер с настройкой устройств_. Пример того, как соединить три местоположения вместе с помощью общих ключей, приведен ниже в этой главе, и станет понятно, почему режим с предварительным общим ключом не подходит для трех сторон или пользователей.
Основные преимущества использования режима предустановленного общего ключа:

* Его очень легко настроить
* Нет необходимости в **инфраструктуре открытого ключа (public key infrastructure - PKI)** или сертификатах X.509
* Может работать на ограниченном оборудовании, таком как коммутаторы или маршрутизаторы на основе Linux

Недостатками использования режима предварительного общего ключа являются:

* Как указывает имя _точка-точка_, только две конечные точки могут использоваться одним соединением. Поэтому этот режим плохо масштабируется.
* Некоторые оболочки GUI для OpenVPN (например, GNOME NetworkManager) не поддерживают предустановленные общие ключи. То же самое относится к клиентам Android и iOS.
* Секретный ключ должен быть скопирован в удаленную конечную точку с использованием безопасного канала, например, с использованием SSH. Иногда это может быть угрозой безопасности.
* Невозможно зашифровать секретный ключ с помощью ключевой фразы, как это возможно при использовании открытых/закрытых ключей X.509.
* Он считается несколько менее безопасным, поскольку безопасность полностью зависит от безопасности и надежности предварительно общего секретного ключа. Кроме того, в этом режиме нет **идеальной секретности пересылки (perfect forwarding secrecy - PFS)**. Без PFS злоумышленник может записать весь зашифрованный трафик VPN. Если злоумышленнику удастся в какой-то момент нарушить шифрование, тогда _весь_ записанный трафик VPN может быть дешифрован. С PFS невозможно расшифровать _старые_ данные.

Важно понимать, что OpenVPN на самом деле работает по-разному при использовании предустановленных общих ключей по сравнению с использованием сертификатов и настройкой клиент/сервер. Пути кода, которые следуют в OpenVPN, на самом деле сильно отличаются, например, согласование канала управления не требуется. Среднестатистический конечный пользователь не увидит эти различия, но важно знать эти различия, когда необходимо устранить неполадки для соединения OpenVPN. Кроме того, при чтении В файле журнала OpenVPN с высокой детальностью вывода (т.е. что-либо выше 5), выходные данные подключения с предварительным общим ключом будут выглядеть совершенно иначе по сравнению с выходными данными подключения на основе сертификатов.

Если не указано иное, все примеры в этой главе основаны на конечных точках под управлением CentOS 6 64bit. Версия установленного программного обеспечения OpenVPN v2.3.2 взята из репозитория CentOS-EPEL.

### Первый пример

Давайте посмотрим на наш самый первый пример:

1.  Самый простой и краткий пример подключения двух компьютеров с использованием OpenVPN - это запуск первой конечной точки в режиме прослушивания с использованием фиксированных IP-адресов и сети в стиле tun:
    ```
    [root@server] # openvpn \
        --ifconfig 10.200.0.1 10.200.0.2 \
        --dev tun
    ```
* Затем запустите клиент OpenVPN:

```
[root@client] # openvpn \
--ifconfig 10.200.0.2 10.200.0.1 \
--dev tun \
--remote openvpnserver.example.com
```

* В другом окне терминала отобразите сетевое устройство:

```
[root@client] # ip addr show tun0
7: tun0: <POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP> mtu 1500
qdisc pfifo_fast state UNKNOWN group default
qlen 100 link/none
inet 10.200.0.2 peer 10.200.0.1/32 scope global tun0
valid_lft forever preferred_lft forever
```

На следующих снимках экрана показано, как устанавливается соединение:

![](pics/pic2-1.png)

* Теперь мы можем пропинговать конечные точки OpenVPN с любого конца, при условии, что правила брандмауэра и SELinux позволяют это.

Журнал подключения показывает некоторые интересные детали. Версия OpenVPN на стороне клиента: `2.3.2 x86_64-redhat-linux-gnu`. Это подтверждает, что мы запускаем v2.3.2 на 64-битной версии производной RedHat Linux.

Журнал подключения показывает предупреждение:

```
Mon Sep 8 18:27:29 2014 ******* WARNING *******: all encryption and
authentication features disabled -- all data will be tunnelled as
cleartext
```

Это предупреждение выводится, поскольку не был указан секретный ключ для шифрования соединения, что делает этот пример не очень безопасным.

*   Устройство Linux `tun0` открыто для подключения. Мы указали `--dev tun`, который сообщает OpenVPN открыть первый доступный адаптер `tun`. Если теперь запущено второе соединение OpenVPN, следующий экземпляр будет использовать `tun1`.
*   Команда Linux `iproute2 /sbin/ip` используется для настройки сетевого адаптера `tun0`. Указанный IP-адрес назначается вместе с **максимальной единицей передачи** по умолчанию **(maximum transfer unit - MTU)** 1500 байтов.
*   По умолчанию OpenVPN будет использовать UDP-порт 1194 для установления соединения. Если требуется протокол TCP, то аргументы командной строки на обоих концах немного различаются (это показано в следующем разделе).
*   Из временных меток, напечатанных в начале каждой строки, видно, что для установления начального соединения требуется 10 секунд.

Если распечатано следующее сообщение, то соединение было успешно установлено. Однако в следующих примерах мы увидим, что это не обязательно означает, что VPN работает нормально.

```
Mon Sep 8 18:27:40 2014 Initialization Sequence Completed
```

### Протокол TCP и разные порты

Протоколом по умолчанию, используемым OpenVPN, является UDP, так как он обычно больше подходит для VPN-подключений. Однако, если требуется протокол TCP, предыдущий пример необходимо изменить лишь незначительно: на конце прослушивания запустите экземпляр сервера OpenVPN:

```
[root@server] # openvpn \
--ifconfig 10.200.0.1 10.200.0.2 \
--dev tun \
--proto tcp-server
```

На стороне клиента код выглядит следующим образом:

```
[root@client] # openvpn \
--ifconfig 10.200.0.2 10.200.0.1 \
--dev tun \
--proto tcp-client \
--remote openvpnserver.example.com
```

OpenVPN теперь будет подключаться через TCP-порт 1194. Также возможно изменить номер порта, используя параметр `--port`, например `--port 5000`.

### Режим TAP

Если трафик не-TCP/IP необходимо передавать через VPN-туннель (например, устаревший трафик AppleTalk или IPX), то требуется _tap_-устройство. _tap_-устройство позволяет интерфейсу передавать полные кадры Ethernet через VPN туннель. Затраты при прохождении полных кадров Ethernet незначительны. Назначение IP для устройства _tap_ отличается от устройства tun, поскольку устройство _tap_ действует как _обычный_ сетевой адаптер, которому необходимо назначить один IP-адрес и сетевую маску.

Предыдущий пример теперь изменен. На конце прослушивания запустите процесс сервера OpenVPN:

```
[root@server] # openvpn \
--ifconfig 10.200.0.1 255.255.255.0 \
--dev tap
```

На стороне клиента код выглядит следующим образом:

```
[root@client] # openvpn \
--ifconfig 10.200.0.2 255.255.255.0 \
--dev tap \
--remote openvpnserver.example.com
```

Опять же, мы перечислим конфигурацию сетевого устройства:

```
[root@client] # ip addr show tap0
8: tap0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500
qdisc pfifo_fast state UNKNOWN group default qlen 100
link/ether 6e:ea:0e:47:a3:d8 brd ff:ff:ff:ff:ff:ff
inet 10.200.0.2/24 brd 10.200.0.255 scope global tap0
valid_lft forever preferred_lft forever
inet6 fe80::6cea:eff:fe47:a3d8/64 scope link
valid_lft forever preferred_lft forever
```

Сравните это с конфигурацией из самого первого примера.
