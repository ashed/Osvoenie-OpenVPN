# Глава 2. Режим точка-точка

Сначала, режим «точка-точка» с использованием общих ключей был единственным доступным вариантом при использовании OpenVPN. В настоящее время существует несколько способов использования OpenVPN, но режим «точка-точка» все еще имеет свое применение. Термин _двухточечный режим с использованием предварительно установленных общих ключей_ часто сокращается до **предустановленных ключей**.

В режиме «точка-точка» OpenVPN настраивается с использованием предустановленных общих секретных ключей для предварительно определенных конечных точек, и только одна конечная точка может одновременно подключаться к экземпляру сервера. Термин сервер можно считать вводящим в заблуждение, поскольку обе конечные точки более или менее равны, когда речь заходит о функциональности. Конечная точка, инициирующая соединение, считается клиентом, а другая конечная точка рассматривается как сервер.

Мы начнем с демонстрации очень простого примера. После этого мы обсудим больше возможностей, которые предоставляет OpenVPN. Мы рассмотрим следующие темы:

* Протокол TCP и разные порты
* Режим TAP
* Секретные ключи OpenVPN
* Маршрутизация
* Полная настройка, включая IPv6
* Настройка без IP
* Трехсторонняя маршрутизация
* Мостовые адаптеры TAP на обоих концах
* Комбинированный двухточечный режим с сертификатами

## Плюсы и минусы ключевого режима

Основным вариантом использования режима предустановленного общего ключа является подключение двух удаленных сетей, например, главного офиса и удаленного офиса небольшой компании. Как только требуется более трех пользователей или конечных точек, гораздо проще использовать режим клиент/сервер, как описано в [Главе 4](chapter-04.md), _Режим клиент/сервер с настройкой устройств_. Пример того, как соединить три местоположения вместе с помощью общих ключей, приведен ниже в этой главе, и станет понятно, почему режим с предустановленным ключом не подходит для трех сторон или пользователей.

Основные преимущества использования режима предустановленного общего ключа:

* Его очень легко настроить
* Нет необходимости в **инфраструктуре открытого ключа (public key infrastructure - PKI)** или сертификатах X.509
* Может работать на ограниченном оборудовании, таком как коммутаторы или маршрутизаторы на основе Linux

Недостатками использования режима предустановленного ключа являются:

* Как указывает имя _точка-точка_, только две конечные точки могут использоваться одним соединением. Поэтому этот режим плохо масштабируется.
* Некоторые оболочки GUI для OpenVPN (например, GNOME NetworkManager) не поддерживают предустановленные общие ключи. То же самое относится к клиентам Android и iOS.
* Секретный ключ должен быть скопирован в удаленную конечную точку с использованием безопасного канала, например, с использованием SSH. Иногда это может быть угрозой безопасности.
* Невозможно зашифровать секретный ключ с помощью ключевой фразы, как это возможно при использовании открытых/закрытых ключей X.509.
* Он считается несколько менее безопасным, поскольку безопасность полностью зависит от безопасности и надежности предварительно общего секретного ключа. Кроме того, в этом режиме нет **идеальной секретности пересылки (perfect forwarding secrecy - PFS)**. Без PFS злоумышленник может записать весь зашифрованный трафик VPN. Если злоумышленнику удастся в какой-то момент нарушить шифрование, тогда _весь_ записанный трафик VPN может быть дешифрован. С PFS невозможно расшифровать _старые_ данные.

Важно понимать, что OpenVPN на самом деле работает по-разному при использовании предустановленных общих ключей по сравнению с использованием сертификатов и настройкой клиент/сервер. Пути кода, которые следуют в OpenVPN, на самом деле сильно отличаются, например, согласование канала управления не требуется. Среднестатистический конечный пользователь не увидит эти различия, но важно знать эти различия, когда необходимо устранить неполадки для соединения OpenVPN. Кроме того, при чтении В файле журнала OpenVPN с высокой детальностью вывода (т.е. что-либо выше 5), выходные данные подключения с предварительным общим ключом будут выглядеть совершенно иначе по сравнению с выходными данными подключения на основе сертификатов.

Если не указано иное, все примеры в этой главе основаны на конечных точках под управлением CentOS 6 64bit. Версия установленного программного обеспечения OpenVPN v2.3.2 взята из репозитория CentOS-EPEL.

### Первый пример

Давайте посмотрим на наш самый первый пример:

1.  Самый простой и краткий пример подключения двух компьютеров с использованием OpenVPN - это запуск первой конечной точки в режиме прослушивания с использованием фиксированных IP-адресов и сети в стиле tun:

```
    [root@server] # openvpn \
        --ifconfig 10.200.0.1 10.200.0.2 \
        --dev tun
```
* Затем запустите клиент OpenVPN:

```
[root@client] # openvpn \
--ifconfig 10.200.0.2 10.200.0.1 \
--dev tun \
--remote openvpnserver.example.com
```

* В другом окне терминала отобразите сетевое устройство:

```
[root@client] # ip addr show tun0
7: tun0: <POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP> mtu 1500
qdisc pfifo_fast state UNKNOWN group default
qlen 100 link/none
inet 10.200.0.2 peer 10.200.0.1/32 scope global tun0
valid_lft forever preferred_lft forever
```

На следующих снимках экрана показано, как устанавливается соединение:

![](pics/pic2-1.png)

* Теперь мы можем пропинговать конечные точки OpenVPN с любого конца, при условии, что правила брандмауэра и SELinux позволяют это.

Журнал подключения показывает некоторые интересные детали. Версия OpenVPN на стороне клиента: `2.3.2 x86_64-redhat-linux-gnu`. Это подтверждает, что мы запускаем v2.3.2 на 64-битной версии производной RedHat Linux.

Журнал подключения показывает предупреждение:

```
Mon Sep 8 18:27:29 2014 ******* WARNING *******: all encryption and
authentication features disabled -- all data will be tunnelled as
cleartext
```

Это предупреждение выводится, поскольку не был указан секретный ключ для шифрования соединения, что делает этот пример не очень безопасным.

*   Устройство Linux `tun0` открыто для подключения. Мы указали `--dev tun`, который сообщает OpenVPN открыть первый доступный адаптер `tun`. Если теперь запущено второе соединение OpenVPN, следующий экземпляр будет использовать `tun1`.
*   Команда Linux `iproute2 /sbin/ip` используется для настройки сетевого адаптера `tun0`. Указанный IP-адрес назначается вместе с **максимальной единицей передачи** по умолчанию **(maximum transfer unit - MTU)** 1500 байтов.
*   По умолчанию OpenVPN будет использовать UDP-порт 1194 для установления соединения. Если требуется протокол TCP, то аргументы командной строки на обоих концах немного различаются (это показано в следующем разделе).
*   Из временных меток, напечатанных в начале каждой строки, видно, что для установления начального соединения требуется 10 секунд.

Если распечатано следующее сообщение, то соединение было успешно установлено. Однако в следующих примерах мы увидим, что это не обязательно означает, что VPN работает нормально.

```
Mon Sep 8 18:27:40 2014 Initialization Sequence Completed
```

### Протокол TCP и разные порты

Протоколом по умолчанию, используемым OpenVPN, является UDP, так как он обычно больше подходит для VPN-подключений. Однако, если требуется протокол TCP, предыдущий пример необходимо изменить лишь незначительно: на конце прослушивания запустите экземпляр сервера OpenVPN:

```
[root@server] # openvpn \
--ifconfig 10.200.0.1 10.200.0.2 \
--dev tun \
--proto tcp-server
```

На стороне клиента код выглядит следующим образом:

```
[root@client] # openvpn \
--ifconfig 10.200.0.2 10.200.0.1 \
--dev tun \
--proto tcp-client \
--remote openvpnserver.example.com
```

OpenVPN теперь будет подключаться через TCP-порт 1194. Также возможно изменить номер порта, используя параметр `--port`, например `--port 5000`.

### Режим TAP

Если трафик не-TCP/IP необходимо передавать через VPN-туннель (например, устаревший трафик AppleTalk или IPX), то требуется _tap_-устройство. _tap_-устройство позволяет интерфейсу передавать полные кадры Ethernet через VPN туннель. Затраты при прохождении полных кадров Ethernet незначительны. Назначение IP для устройства _tap_ отличается от устройства tun, поскольку устройство _tap_ действует как _обычный_ сетевой адаптер, которому необходимо назначить один IP-адрес и сетевую маску.

Предыдущий пример теперь изменен. На конце прослушивания запустите процесс сервера OpenVPN:

```
[root@server] # openvpn \
--ifconfig 10.200.0.1 255.255.255.0 \
--dev tap
```

На стороне _клиента_ код выглядит следующим образом:

```
[root@client] # openvpn \
--ifconfig 10.200.0.2 255.255.255.0 \
--dev tap \
--remote openvpnserver.example.com
```

Опять же, мы перечислим конфигурацию сетевого устройства:

```
[root@client] # ip addr show tap0
8: tap0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500
qdisc pfifo_fast state UNKNOWN group default qlen 100
link/ether 6e:ea:0e:47:a3:d8 brd ff:ff:ff:ff:ff:ff
inet 10.200.0.2/24 brd 10.200.0.255 scope global tap0
valid_lft forever preferred_lft forever
inet6 fe80::6cea:eff:fe47:a3d8/64 scope link
valid_lft forever preferred_lft forever
```

Сравните это с конфигурацией из самого первого примера.

## Топология подсети

OpenVPN 2.1 и более поздние версии поддерживают новую топологию, топологию подсети для назначения IP-адресов в сетях в стиле tun, которая очень похожа на IP-адреса, используемые в сетях в стиле tap. При использовании `--topology subnet` одному интерфейсу туннеля назначаются один IP-адрес и маска сети, а адрес партнера не указывается.

Хотя использовать этот режим топологии для выделенной двухточечной связи не имеет большого смысла, этот параметр топологии можно использовать, чтобы сделать настройку режима точка-точка стиля tun практически такой же, как соответствующая настройка tap-стиля. Чтобы использовать этот новый режим топологии, используйте настройку, описанную ниже.

На конце прослушивания начните:

```
[root@server] # openvpn \
--ifconfig 10.200.0.1 255.255.255.0 \
--dev tun \
--topology subnet
```

На стороне клиента код выглядит следующим образом:

```
[root@client] # openvpn \
--ifconfig 10.200.0.2 255.255.255.0 \
--dev tun \
--topology subnet \
--remote openvpnserver.example.com
```

Линия `--ifconfig` теперь такая же, как для примера tap. Единственное изменение - добавление `--topology subnet` на обоих концах.

## Туннель открытого текста

Предыдущий пример не использует шифры шифрования или ключи аутентификации; следовательно, вы получаете следующее предупреждение:

```
Mon Sep 8 18:27:29 2014 ******* WARNING *******: all encryption and authentication features disabled -- all data will be tunnelled as cleartext
```

Тем не менее, туннель открытого текста имеет свои применения. В доверенной среде, где безопасность обрабатывается на другом уровне (например, с использованием выделенного оптоволоконного кабеля), туннель с открытым текстом обеспечивает лучшую производительность по зашифрованному туннелю, и легче отслеживается поток трафика по туннелю.

Кроме того, если вы заранее знаете, что весь трафик, который будет проходить через туннель, зашифрован сам (например, весь трафик строго HTTPS), то можно использовать туннель открытого текста, чтобы избежать двойного шифрования, что иногда может привести к снижению производительности. Особенно при работе OpenVPN на небольшом или встроенном оборудовании (например, Raspberry Pi или даже на некоторых платах Arduino) шифрование наносит большой удар по производительности.

Туннель открытого текста может быть настроен с использованием примеров, приведенных в предыдущем разделе. Если секретный ключ не указан, шифрование и аутентификация (подпись HMAC) автоматически отключаются. Также возможно отключить их явно:

На конце прослушивания запустите:

```
[root@server] # openvpn \
--ifconfig 10.200.0.1 10.200.0.2 \
--dev tun \
--cipher none --auth none
```

На стороне клиента код выглядит следующим образом:

```
[root@client] # openvpn \
--ifconfig 10.200.0.2 10.200.0.1 \
--dev tun \
--cipher none --auth none \
--remote openvpnserver.example.com
```

После того, как соединение установлено, мы можем проверить что содержимое действительно отправлено в виде открытого текста, используя команду `tcpdump` (или эквивалентную, например, Wireshark):

1. Запустите соединение.
2. Запустите `tcpdump` и прослушивайте _обычный_ сетевой интерфейс, а не сам туннельный и отфильтруйте пакеты OpenVPN (`UDP port 1194`) с помощью следующей команды:

```
[root@server] # tcpdump -l -w - eth0 udp port 1194 | strings
```

3.  Теперь отправьте текст через туннель, например, `nc` (netcat):

   - На стороне сервера:

```
     $ nc -l -p 31000
```

  - На стороне клиента:

```
    $ nc 10.200.0.1 31000
    hello from openvpn client
    goodbye
```

4. Вывод `tcpdump` теперь должен показать что-то вроде этого:

```
tcpdump: listening on eth0, link-type EN10MB (Ethernet),
capture size 65535 bytes
V~hello from openvpn client
5goodbye
```

Символы, показанные в виде текстовых сообщений, являются артефактами инкапсуляции пакетов OpenVPN.

## Секретные ключи OpenVPN

Для защиты соединения OpenVPN необходим секретный ключ. Сначала мы сгенерируем такой ключ. Затем его необходимо скопировать в удаленную конечную точку с использованием безопасного канала (например, SCP):

```
$ openvpn --genkey --secret secret.key
```

Обратите внимание, что нет необходимости запускать эту команду от пользователя root (отсюда и приглашение `$`). Полученный файл секретного ключа имеет следующий формат:

```
##
2048 bit OpenVPN static key
#-
----BEGIN OpenVPN Static key V1-----
1393ae687606c1f7d465d70227bf63e8
8963e9d1401450002d073d6eab1bffde
b06d1a33cc5c45d4a667016339e921d3
3ac36b1a949eb52e9217e41e4b035a7b
987ddfa9d6766d3b5e4c952dc27f518d
12ccff6b2f0966284382ddc0f62b824a
f576f0982beec9d6a4728d0788499a75
0fd7055ef681404fd463d9862d3a40a9
31fca7d87997c70c07b8303a1b85f1ff
76aa7790e7c341353d2b4ea5049b11a2
51346e7dd39fc1f1e53ae57c46cf60c8
24db00a871262fee78050a9df6a57322
0bb0d980b6cf1be90a2f304f99fb9cde
7cdf72d20e7dee555c7c99950aa4d8e6
86a020c3a63125fb99d56181ff4ca20c
d6711eab15a4d6faf706f2601eb6 61b7
-----END OpenVPN Static key V1-----
```

После публикации ключа здесь, это уже не секрет.

Команда `openvpn --genkey` генерирует 2048-битный ключ или 256 байтов случайных данных. Эти 256 байтов перечислены в шестнадцатеричном формате в файле `secret.key`, но в настоящее время используются не все 256 байтов (как мы увидим позже).

Секретный ключ используется OpenVPN для шифрования и аутентификации(подписи) каждого пакета. Шифр шифрования по умолчанию - это шифр Blowfish (BF-CBC), а алгоритм HMAC по умолчанию - SHA1. Шифр Blowfish использовал 128-битное шифрование, тогда как ключ, используемый для алгоритма SHA1, составляет 160 бит.

Если OpenVPN запускается с увеличенным выходом отладки (`--verb 7` или выше), используемые ключи печатаются при запуске:

На слушающем конце (сервере) запустите демон OpenVPN:

```
[root@server] # openvpn \
--ifconfig 10.200.0.1 10.200.0.2 \
--dev tun \
--secret secret.key \
--verb 7
```

На стороне клиента команда выглядит следующим образом:

```
[root@client] # openvpn \
--ifconfig 10.200.0.2 10.200.0.1 \
--dev tun \
--secret secret.key \
--remote openvpnserver.example.com
```

Вывод журнала на стороне сервера будет содержать строки вида:

```
Static Encrypt: Cipher 'BF-CBC' initialized with 128 bit key
Static Encrypt: CIPHER KEY: 1393ae68 7606c1f7 d465d702 27bf63e8
Static Encrypt: CIPHER block_size=8 iv_size=8
Static Encrypt: Using 160 bit message hash 'SHA1' for
HMAC authentication
Static Encrypt: HMAC KEY: 987ddfa9 d6766d3b 5e4c952d c27f518d
12ccff6b
Static Encrypt: HMAC size=20 block_size=20
Static Decrypt: Cipher 'BF-CBC' initialized with 128 bit key
Static Decrypt: CIPHER KEY: 1393ae68 7606c1f7 d465d702 27bf63e8
Static Decrypt: CIPHER block_size=8 iv_size=8
Static Decrypt: Using 160 bit message hash 'SHA1' for
HMAC authentication
Static Decrypt: HMAC KEY: 987ddfa9 d6766d3b 5e4c952d c27f518d
12ccff6b
Static Decrypt: HMAC size=20 block_size=20
```

Ключ шифра `BF-CBC` - это `1393 ae68 7606 c1f7 d465 D702 27bf 63e8`, что точно соответствует первой строке файла секретного ключа OpenVPN.

`SHA1` ключом HMAC является `987d dfa9 d676 6d3b 5e4c 952d c27f 518d 12cc ff6b`, который также можно найти в файле секретного ключа, начиная с пятой строки.

Обратите внимание, что одни и те же ключи используются для шифрования и дешифрования данных, а также аутентификации данных. В следующем разделе мы увидим, как мы можем использовать разные ключи для шифрования, дешифрования и аутентификации.

### Использование нескольких ключей

OpenVPN поддерживает использование _направленных_ ключей, то есть различные ключи используются для входящих и исходящих данных. Это еще больше повышает безопасность. Добавив флаг _направления_ к параметру `--secret` мы можем указать, что будут использоваться различные ключи. Флаг _направления_ должен быть установлен в `0` на одном конце и в `1` на другом:

На прослушивающем конце (сервер), запустите:

```
[root@server] # openvpn \
--ifconfig 10.200.0.1 10.200.0.2 \
--dev tun \
--secret secret.key 0\
--verb 7
```

На стороне клиента код выглядит следующим образом:

```
[root@client] # openvpn \
--ifconfig 10.200.0.2 10.200.0.1 \
--dev tun \
--secret secret.key 1\
--remote openvpnserver.example.com \
--verb 7
```

Вывод журнала на стороне сервера теперь будет содержать строки вида:

```
Static Encrypt: CIPHER KEY: 1393ae68 7606c1f7 d465d702 27bf63e8
Static Encrypt: HMAC KEY: 987ddfa9 d6766d3b 5e4c952d c27f518d
12ccff6b
Static Decrypt: CIPHER KEY: 31fca7d8 7997c70c 07b8303a 1b85f1ff
Static Decrypt: HMAC KEY: 0bb0d980 b6cf1be9 0a2f304f 99fb9cde
7cdf72d2
```

Ключи шифрования `CIPHER` и `HMAC` теперь явно отличаются от ключей дешифрования `CIPHER` и `HMAC`. Кроме того, каждый из этих ключей можно найти в файле OpenVPN `secret.key`:

* Ключ шифрования `CIPHER KEY` начинается с 1 строки длиной 128 бит или 16 байт.
* Ключ шифрования `HMAC KEY` начинается с 5 строки длиной 160 бит или 20 байтов.
* Ключ дешифрования `CIPHER KEY` начинается с 9 строки длиной 128 бит или 16 байтов
* Ключ расшифровки `HMAC KEY` начинается с 13 строки длиной 160 бит или 20 байтов.

Кроме того, вывод журнала на стороне клиента показывает, что ключи поменялись местами:

```
Static Encrypt: CIPHER KEY: 31fca7d8 7997c70c 07b8303a 1b85f1ff
Static Encrypt: HMAC KEY: 0bb0d980 b6cf1be9 0a2f304f 99fb9cde 7cdf72d2
Static Decrypt: CIPHER KEY: 1393ae68 7606c1f7 d465d702 27bf63e8
Static Decrypt: HMAC KEY: 987ddfa9 d6766d3b 5e4c952d c27f518d 12ccff6b
```

Это необходимо для функционирования VPN-туннеля, так как ключи, которые необходимы на стороне сервера для _шифрования_ данных, необходимы на стороне клиента для _дешифрования_ данных и наоборот.
